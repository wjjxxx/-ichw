1，图灵机的停机问题

2，二进制补码的原理
  
  首先，我们需要先了解原码。在计算机用一个数的最高位存放符号，正数为0，负数为1。第一位是符号位，所以8位二进制数的取值范围就是:[11111111， 01111111]即[-127，127]。例如，十进制中的数+3 ，计算机字长为8位，转换成二进制就是00000011。若是 -3 ，则是 10000011 。
  
  我们知道第一位是符号位，可以辨别，并对其对应的真值进行运算。但是对于机器而言，要求设计尽量简单，如果要机器辨认符号位必然会让机器更加复杂。比如，在进行加减的时候，首先要辨认符号，然后进行加减，很麻烦。于是人们想出了将符号位也参与运算的方法。由于减去一个正数等于加上一个负数，即: 1-1=1+(-1)=0，所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了。
  
  首先，我们可以将原码进行这样的加减运算。计算十进制的表达式: 1-1=0：1-1=1+(-1)=[00000001]原+[10000001]原=[10000010]原=-2。如果用原码表示，让符号位也参与计算，对于减法来说，显然结果是不正确的。
  
  然后，为了解决这个问题，出现了反码。反码的表示方法是:正数的反码是其本身；负数的反码是在其原码的基础上，符号位不变，其余的各个位取反。例如：[+7]原=00000111，[-7]原=10000111；[+7]反=00000111，[-7]反=11111000。这样，我们再来进行加减运算：计算十进制的表达式: 1-1=0：1-1=1+(-1)=[0000 0001]原 + [10000001]原=[00000001]反+[11111110]反=[11111111]反=[10000000]原=-0。这样，运算的结果就对了。
  
  但是，还有另外的问题。对于0这个数，出现了两个可以表示它的：+0和—0。于是，就出现了补码。
  
  补码的表示方法是:正数的补码就是其本身；负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1（在反码的基础上+1）。这样子，就不会出现两个0；而且，我们还可以比反码多表示一个数：（字长8位）-128。
  
  这就是补码的原理。

3，IEEE 754浮点数格式的 16 bit 浮点数表示

 +0：0 0000000 00000000                  
 -0： 1 0000000 00000000
 
 1.0：0	0111111	00000000              
 -1.0：1 0111111 00000000
 
最大非规范化数：0 0000000	11111111        最小非规范化数：1 0000000 11111111

最小规范化浮点数：1 1111110 11111111      最大规范化浮点数：0 1111110 11111111

+∞：0 1111111 00000000                   -∞：1 1111111 00000000

NaN：* 1111111 non zero
